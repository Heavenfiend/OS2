#include <pthread.h>
#include <unistd.h>
#include <sys/mman.h>
#include <time.h>
#include <limits.h>

#define MY_MALLOC(size) mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
#define MY_FREE(ptr, size) munmap(ptr, size)

static struct timespec get_time_counter() { struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts); return ts; }
static double elapsed_ms(struct timespec start, struct timespec end) {
    long seconds = end.tv_sec - start.tv_sec;
    long nanoseconds = end.tv_nsec - start.tv_nsec;
    return (double)seconds * 1000.0 + (double)nanoseconds / 1000000.0;
}

#define sleep_ms(ms) usleep((ms) * 1000)

typedef struct { int id; int* arr; int lo; int n; int dir; int max_threads; } thread_data_t;

int active_threads = 0;
pthread_mutex_t thread_count_mutex = PTHREAD_MUTEX_INITIALIZER;

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void bitonic_compare(int* arr, int idx1, int idx2, int dir) {
    if ((arr[idx1] > arr[idx2]) == dir) {
        swap(&arr[idx1], &arr[idx2]);
    }
}

void bitonic_merge(int* arr, int lo, int n, int dir) {
    if (n <= 1) return;
    int m = 1;
    while (m < n) m <<= 1;
    m >>= 1;
    for (int i = lo; i < lo + n - m; i++) {
        bitonic_compare(arr, i, i + m, dir);
    }
    bitonic_merge(arr, lo, m, dir);
    bitonic_merge(arr, lo + m, n - m, dir);
}

void bitonic_sort_seq(int* arr, int lo, int n, int dir) {
    if (n <= 1) return;
    int m = n / 2;
    bitonic_sort_seq(arr, lo, m, 1);
    bitonic_sort_seq(arr, lo + m, n - m, 0);
    bitonic_merge(arr, lo, n, dir);
}

void* merge_sort_thread(void* arg) {
    thread_data_t* data = (thread_data_t*)arg;
    bitonic_merge(data->arr, data->lo, data->n, data->dir);
    
    pthread_mutex_lock(&thread_count_mutex);
    active_threads--;
    pthread_mutex_unlock(&thread_count_mutex);
    
    return NULL;
}

void* bitonic_sort_thread(void* arg) {
    thread_data_t* data = (thread_data_t*)arg;
    if (data->n <= 1) {
        pthread_mutex_lock(&thread_count_mutex);
        active_threads--;
        pthread_mutex_unlock(&thread_count_mutex);
        return NULL;
    }

    int m = data->n / 2;
    pthread_t t1, t2;

    thread_data_t d1 = {0, data->arr, data->lo, m, 1, data->max_threads};
    thread_data_t d2 = {0, data->arr, data->lo + m, data->n - m, 0, data->max_threads};

    pthread_mutex_lock(&thread_count_mutex);
    if (active_threads >= data->max_threads) {
        pthread_mutex_unlock(&thread_count_mutex);
        bitonic_sort_seq(data->arr, data->lo, m, 1);
        bitonic_sort_seq(data->arr, data->lo + m, data->n - m, 0);
    } else {
        active_threads += 2;
        pthread_mutex_unlock(&thread_count_mutex);
        pthread_create(&t1, NULL, bitonic_sort_thread, &d1);
        pthread_create(&t2, NULL, bitonic_sort_thread, &d2);
        pthread_join(t1, NULL);
        pthread_join(t2, NULL);
    }

    pthread_t t3;
    thread_data_t d3 = {0, data->arr, data->lo, data->n, data->dir, data->max_threads};

    pthread_mutex_lock(&thread_count_mutex);
    if (active_threads < data->max_threads) {
        active_threads++;
        pthread_mutex_unlock(&thread_count_mutex);
        pthread_create(&t3, NULL, merge_sort_thread, &d3);
        pthread_join(t3, NULL);
    } else {
        pthread_mutex_unlock(&thread_count_mutex);
        bitonic_merge(data->arr, data->lo, data->n, data->dir);
    }

    pthread_mutex_lock(&thread_count_mutex);
    active_threads--;
    pthread_mutex_unlock(&thread_count_mutex);
    
    return NULL;
}

static unsigned int seed = 12345;

void generate_random_array(int* arr, int n) {
    for (int i = 0; i < n; i++) {
        seed = seed * 1103515245 + 12345;
        arr[i] = (seed >> 16) % 10000;
    }
}

void my_memcpy(void* dest, const void* src, size_t n) {
    char* d = (char*)dest;
    const char* s = (const char*)src;
    for (size_t i = 0; i < n; i++) {
        d[i] = s[i];
    }
}

void* my_malloc(size_t size) {
    return MY_MALLOC(size);
}

void my_free(void* ptr, size_t size) {
    if (ptr) MY_FREE(ptr, size);
}

int int_to_str(long num, char* buffer, int buffer_size) {
    if (buffer_size <= 0) return 0;
    if (num == 0) {
        if (buffer_size > 1) {
            buffer[0] = '0';
            buffer[1] = '\0';
            return 1;
        } else {
            return 0;
        }
    }

    int sign = 0;
    if (num < 0) {
        sign = 1;
        if (num == LONG_MIN) {
             const char* min_str = "-9223372036854775808";
             int len = 0;
             while (min_str[len] != '\0' && len < buffer_size - 1) {
                 buffer[len] = min_str[len];
                 len++;
             }
             if (len < buffer_size) {
                 buffer[len] = '\0';
                 return len;
             } else {
                 return 0;
             }
        }
        num = -num;
    }

    char temp[21];
    int temp_len = 0;
    while (num > 0 && temp_len < 20) {
        temp[temp_len++] = (num % 10) + '0';
        num /= 10;
    }

    int start = 0;
    if (sign && buffer_size > temp_len + 1) {
        buffer[0] = '-';
        start = 1;
    } else if (sign) {
        return 0;
    }

    if (buffer_size <= start + temp_len) {
        return 0;
    }

    for (int i = 0; i < temp_len; i++) {
        buffer[start + i] = temp[temp_len - 1 - i];
    }
    buffer[start + temp_len] = '\0';
    return start + temp_len;
}

int double_to_str(double num, char* buffer, int buffer_size) {
    if (buffer_size <= 0) return 0;

    long long_num_part = (long)num;
    if (num < 0 && num != (double)long_num_part) {
        long_num_part--;
    }
    double frac_part = num - long_num_part;

    char int_buf[25];
    int int_len = int_to_str(long_num_part, int_buf, 25);
    if (int_len <= 0) return 0;

    long frac_as_int = (long)(frac_part * 100 + (frac_part >= 0 ? 0.5 : -0.5));
    if (frac_as_int < 0) frac_as_int = -frac_as_int;

    char frac_buf[5];
    frac_buf[0] = '.';
    int_to_str(frac_as_int, frac_buf + 1, 4);

    int total_len = int_len + 3;
    if (buffer_size <= total_len) {
        return 0;
    }

    for (int i = 0; i < int_len; i++) {
        buffer[i] = int_buf[i];
    }
    for (int i = 0; i < 3; i++) {
        buffer[int_len + i] = frac_buf[i];
    }
    buffer[total_len] = '\0';

    return total_len;
}

void print_string(const char* str) {
    int len = 0;
    while (str[len] != '\0') len++;
    write(STDOUT_FILENO, str, len);
}

void println_string(const char* str) {
    print_string(str);
    write(STDOUT_FILENO, "\n", 1);
}

void print_int(int num) {
    char buf[12];
    if (int_to_str(num, buf, 12) > 0) {
        print_string(buf);
    }
}

void print_double(double num) {
    char buf[30];
    if (double_to_str(num, buf, 30) > 0) {
        print_string(buf);
    }
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        return 1;
    }
    int num_threads = 0;
    char* num_str = argv[2];
    while (*num_str >= '0' && *num_str <= '9') {
         num_threads = num_threads * 10 + (*num_str - '0');
         num_str++;
    }

    int n = 1000000;
    int* arr = (int*)my_malloc(n * sizeof(int));
    if (!arr) return 1;

    generate_random_array(arr, n);

    int* seq_arr = (int*)my_malloc(n * sizeof(int));
    if (!seq_arr) { my_free(arr, n * sizeof(int)); return 1; }
    my_memcpy(seq_arr, arr, n * sizeof(int));

    struct timespec start = get_time_counter();
    bitonic_sort_seq(seq_arr, 0, n, 1);
    struct timespec end = get_time_counter();
    double seq_time = elapsed_ms(start, end);

    int* par_arr = (int*)my_malloc(n * sizeof(int));
    if (!par_arr) { my_free(arr, n * sizeof(int)); my_free(seq_arr, n * sizeof(int)); return 1; }
    my_memcpy(par_arr, arr, n * sizeof(int));

    active_threads = 1;
    pthread_t main_thread;
    thread_data_t data = {0, par_arr, 0, n, 1, num_threads};

    start = get_time_counter();
    pthread_create(&main_thread, NULL, bitonic_sort_thread, &data);
    pthread_join(main_thread, NULL);
    end = get_time_counter();

    double par_time = elapsed_ms(start, end);
    double speedup = seq_time / par_time;
    double efficiency = speedup / num_threads;

    print_string("Sequential time: ");
    print_double(seq_time);
    println_string(" ms");

    print_string("Parallel time with ");
    print_int(num_threads);
    print_string(" threads: ");
    print_double(par_time);
    println_string(" ms");

    print_string("Speedup: ");
    print_double(speedup);
    println_string("");

    print_string("Efficiency: ");
    print_double(efficiency);
    println_string("");

    my_free(arr, n * sizeof(int));
    my_free(seq_arr, n * sizeof(int));
    my_free(par_arr, n * sizeof(int));

    return 0;
}